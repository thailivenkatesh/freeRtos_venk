/*
 ******************************************************************************
File:     main.c
Info:     Generated by Atollic TrueSTUDIO(R) 9.3.0   2024-07-19

The MIT License (MIT)
Copyright (c) 2019 STMicroelectronics

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

 ******************************************************************************
 */

/* Includes */
#include "stm32l4xx_hal.h"
#include "stm32l4xx.h"

#include <stdio.h>
/* FreeRTOS.org includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "event_groups.h"
#include "task.h"
#include "semphr.h"
#include "message_buffer.h"
#include "stream_buffer.h"
#include "event_groups.h"

// Definitions
SemaphoreHandle_t xBinarySemaphore;
SemaphoreHandle_t xMutex;
SemaphoreHandle_t xCountingSemaphore;
MessageBufferHandle_t xMessageBuffer;
StreamBufferHandle_t xStreamBuffer;
EventGroupHandle_t xEventGroup;

TaskHandle_t myTask1Handle = NULL;
/* MX_GPIO_Init() should be generated by CubeMX or manually defined */
#define BUTTON_PRESSED (1 << 0)

// Task 1: Semaphore & Critical Sections
void vTask1(void *pvParameters) {
	int task1 = 0;
    for (;;) {
        // Wait for the semaphore to become available
        if (xSemaphoreTake(xBinarySemaphore, portMAX_DELAY) == pdTRUE) {
            // Enter critical section
            taskENTER_CRITICAL();
            // Perform critical operations
           // printf("Task 1 is running in the critical section.\n");
            task1 = 1;
            // Exit critical section
            taskEXIT_CRITICAL();
            // Release the semaphore
            xSemaphoreGive(xBinarySemaphore);
        }
        vTaskDelay(pdMS_TO_TICKS(1000)); // Delay for a while
    }
}

// Task 2: Mutex & Message Buffer
void vTask2(void *pvParameters) {
    const char *message = "Hello from Task 2!\n";
    for (;;) {
        // Take the mutex before accessing the message buffer
        if (xSemaphoreTake(xMutex, portMAX_DELAY) == pdTRUE) {
            xMessageBufferSend(xMessageBuffer, message, strlen(message), portMAX_DELAY);
            xSemaphoreGive(xMutex); // Release the mutex
        }
        vTaskDelay(pdMS_TO_TICKS(500)); // Delay for a while
    }
}

void vTask3(void *pvParameters) {
    char rxBuffer[50];
    for (;;) {
        // Take the mutex before accessing the message buffer
        if (xSemaphoreTake(xMutex, portMAX_DELAY) == pdTRUE) {
            xMessageBufferReceive(xMessageBuffer, rxBuffer, sizeof(rxBuffer), portMAX_DELAY);
           // printf("Received: %s", rxBuffer);
            xSemaphoreGive(xMutex); // Release the mutex
        }
        vTaskDelay(pdMS_TO_TICKS(1000)); // Delay for a while
    }
}

// Task 3: Counting Semaphore & Stream Buffer
void vTask4(void *pvParameters) {
    const char *data = "Data from Task 4";
    for (;;) {
        xStreamBufferSend(xStreamBuffer, data, strlen(data), portMAX_DELAY);
        xSemaphoreGive(xCountingSemaphore); // Signal data is available
        vTaskDelay(pdMS_TO_TICKS(500)); // Delay for a while
    }
}

void vTask5(void *pvParameters) {
    char rxData[50];
    for (;;) {
        // Wait for the counting semaphore
        if (xSemaphoreTake(xCountingSemaphore, portMAX_DELAY) == pdTRUE) {
            xStreamBufferReceive(xStreamBuffer, rxData, sizeof(rxData), portMAX_DELAY);
            //printf("Received Stream Buffer Data: %s\n", rxData);
            // Set bits in the event group
                   xEventGroupSetBits(xEventGroup, BUTTON_PRESSED);
        }
        vTaskDelay(pdMS_TO_TICKS(1000)); // Delay for a while
        vTaskSuspend(NULL);
    }
}

// Task 4: Event Groups & Button Interrupt (PC13)
void vTask6(void *pvParameters) {
    for (;;) {
        // Wait for the button press event
        EventBits_t uxBits = xEventGroupWaitBits(
            xEventGroup,
            BUTTON_PRESSED,
            pdTRUE,
            pdFALSE,
            portMAX_DELAY
        );
        if (uxBits & BUTTON_PRESSED) {
            printf("Button Pressed!\n");
        }
        vTaskDelay(pdMS_TO_TICKS(1000)); // Delay for a while
    }
}
void button_init(void)
{
	GPIO_InitTypeDef GPIO_InitStruct;

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOC_CLK_ENABLE();
	/*Configure GPIO pin : PC13 */
	GPIO_InitStruct.Pin = GPIO_PIN_13;
	GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	//GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
	HAL_NVIC_SetPriority(EXTI15_10_IRQn,10,0);
	HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
}


int main(void) {
	// Initialize hardware (e.g., UART, peripherals, etc.)
	button_init();


	 // Create FreeRTOS objects
	    xBinarySemaphore = xSemaphoreCreateBinary();
	    xMutex = xSemaphoreCreateMutex();
	    xCountingSemaphore = xSemaphoreCreateCounting(10, 0); // Max count of 10
	    xMessageBuffer = xMessageBufferCreate(100); // 100 bytes size
	    xStreamBuffer = xStreamBufferCreate(100, 10); // 100 bytes, trigger level 10
	    xEventGroup = xEventGroupCreate();

	    // Create tasks
	    xTaskCreate(vTask1, "Task 1", 128, NULL, 1, NULL);
	    xTaskCreate(vTask2, "Task 2", 128, NULL, 1, NULL);
	    xTaskCreate(vTask3, "Task 3", 128, NULL, 1, NULL);
	    xTaskCreate(vTask4, "Task 4", 128, NULL, 1, NULL);
	    xTaskCreate(vTask5, "Task 5", 128, NULL, 1, &myTask1Handle);
	    xTaskCreate(vTask6, "Task 6", 128, NULL, 1, NULL);


	// Start the scheduler
	vTaskStartScheduler();

	// Should not reach here if the scheduler is running correctly
	while (1);
}




void EXTI15_10_IRQHandler(void)
{
	HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_13);
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
	if (GPIO_Pin == GPIO_PIN_13)
	{
		BaseType_t xHigherPriorityTaskWoken = pdFALSE;
		xTaskResumeFromISR(myTask1Handle);
		//xEventGroupSetBitsFromISR(xEventGroup, BUTTON_PRESSED, &xHigherPriorityTaskWoken);
		portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
	}
}
